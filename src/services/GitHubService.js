import { Octokit } from '@octokit/rest';
import { logger } from '../utils/logger.js';
import { CONFIG } from '../utils/config.js';
import { promisify } from 'util';
import { exec as execCallback } from 'child_process';

const exec = promisify(execCallback);
export class GitHubService {
  constructor() {
    if (!CONFIG.options.github?.token) {
      throw new Error('GitHub token is required');
    }
    this.octokit = new Octokit({ auth: CONFIG.options.github.token });
  }

  async createPullRequest(files) {
    try {
      // Get repo info from remote origin
      const remoteUrl = await this.getRemoteUrl();
      const { owner, repo } = this.parseGitHubUrl(remoteUrl);
      
      const branchName = `docs/update-${Date.now()}`;
      const defaultBranch = await this.getDefaultBranch(owner, repo);
      
      // Create branch
      await this.createBranch(owner, repo, branchName, defaultBranch);
      
      // Commit files
      for (const file of files) {
        await this.commitFile(owner, repo, file, branchName);
      }
      
      // Create PR
      const pr = await this.createPR(owner, repo, branchName, defaultBranch);
      logger.success(`Pull request created: ${pr.html_url}`);
      
      return pr;
    } catch (error) {
      throw new Error(`Failed to create pull request: ${error.message}`);
    }
  }

  async getRemoteUrl() {
    const { stdout } = await exec('git config --get remote.origin.url');
    return stdout.trim();
  }

  parseGitHubUrl(url) {
    const match = url.match(/github\.com[:/]([^/]+)\/([^/.]+)/);
    if (!match) throw new Error('Invalid GitHub URL');
    return { owner: match[1], repo: match[2] };
  }

  async createBranch(owner, repo, branchName, defaultBranch) {
    const { data: ref } = await this.octokit.rest.git.getRef({
      owner,
      repo,
      ref: `heads/${defaultBranch}`
    });

    await this.octokit.rest.git.createRef({
      owner,
      repo,
      ref: `refs/heads/${branchName}`,
      sha: ref.object.sha
    });
  }

  async commitFile(owner, repo, file, branch) {
    await this.createOrUpdateFile({
      owner,
      repo,
      path: file.path,
      content: file.content,
      branch,
      message: `docs: Update ${file.path}`
    });
  }

  async createPR(owner, repo, head, base) {
    const { data } = await this.octokit.rest.pulls.create({
      owner,
      repo,
      title: 'docs: Update documentation',
      body: 'Generated by Docsage',
      head,
      base
    });
    return data;
  }

  async getDefaultBranch(owner, repo) {
    const { data } = await this.octokit.rest.repos.get({
      owner,
      repo
    });
    return data.default_branch;
  }

  async createOrUpdateFile({ owner, repo, path, content, branch, message }) {
    try {
      if (!content) {
        throw new Error(`No content provided for file: ${path}`);
      }
      
      const contentEncoded = Buffer.from(content).toString('base64');
      
      // Try to get existing file
      let sha;
      try {
        const { data } = await this.octokit.repos.getContent({
          owner,
          repo,
          path,
          ref: branch
        });
        sha = data.sha;
      } catch (error) {
        // File doesn't exist yet, which is fine
      }

      await this.octokit.repos.createOrUpdateFileContents({
        owner,
        repo,
        path,
        message,
        content: contentEncoded,
        branch,
        sha
      });
    } catch (error) {
      throw new Error(`Failed to update file ${path}: ${error.message}`);
    }
  }
} 